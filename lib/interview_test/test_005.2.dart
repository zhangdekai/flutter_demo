/*
冒泡排序的实现过程如下：

1: 从列表的第一个元素开始，比较相邻的两个元素，如果顺序不正确（比如，当前元素大于下一个元素），
则交换它们的位置，使得较大的元素“冒泡”到顶部。

2: 继续比较列表中的相邻元素，直到到达列表的末尾。此时，最大的元素已经位于列表的末尾位置。
接着，对剩余的未排序部分重复上述过程，直到整个列表都排序完成。

冒泡排序是一种简单但效率较低的排序算法，其时间复杂度为 O(n^2)。尽管如此，由于其实现简单易懂，对于小规模的数据或者教学目的而言，冒泡排序仍然具有一定的实用价值。然而，在大规模数据的情况下，更高效的排序算法如快速排序、归并排序等往往被更加推荐。
 */

void main() {
  List<int> numbers = [64, 34, 25, 12, 22, 11, 90];

  print('未排序前：');
  print(numbers);

  bubbleSort(numbers);

  print('排序后：');
  print(numbers);
}

void bubbleSort(List<int> arr) {
  int n = arr.length;
  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换 arr[j] 和 arr[j+1]
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
